var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ConvolutionalClosure","category":"page"},{"location":"#ConvolutionalClosure","page":"Home","title":"ConvolutionalClosure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ConvolutionalClosure.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ConvolutionalClosure]","category":"page"},{"location":"#ConvolutionalClosure.Burgers","page":"Home","title":"ConvolutionalClosure.Burgers","text":"(::Burgers)(u, p, t)\n\nCompute right hand side of Burgers equation. This works for both vector and matrix u (one or many solutions).\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.Convection","page":"Home","title":"ConvolutionalClosure.Convection","text":"(::Convection)(u, p, t)\n\nCompute right hand side of convection equation. This works for both vector and matrix u (one or many solutions).\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.Diffusion","page":"Home","title":"ConvolutionalClosure.Diffusion","text":"(::Diffusion)(u, p, t)\n\nCompute right hand side of diffusion equation. This works for both vector and matrix u (one or many solutions).\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.FourierLayer","page":"Home","title":"ConvolutionalClosure.FourierLayer","text":"FourierLayer(n, kmax; σ = identity, init_weight = glorot_uniform_Float64)\n\nFourier layer operating on uniformly discretized functions with n pointwise output values. Inputs and outputs are both arrays of size (n, nx, nsample), where nx is any number of discrete uniform spatial points that is higher than the cut-off frequency kmax, and the nsample samples are treated independently.\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.KortewegDeVries","page":"Home","title":"ConvolutionalClosure.KortewegDeVries","text":"KortewegDeVries(l, N = 2)\n\nKorteweg-De Vries equation with domain length l and order N.\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.KortewegDeVries-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.KortewegDeVries","text":"Compute right hand side of Korteweg-De Vries equation. This works for both vector and matrix u (one or many solutions).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.KuramotoSivashinsky","page":"Home","title":"ConvolutionalClosure.KuramotoSivashinsky","text":"KuramotoSivashinsky(l, N = 2)\n\nKuramoto-Sivashinsky equation with domain length l and order N.\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.KuramotoSivashinsky-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.KuramotoSivashinsky","text":"Compute right hand side of Kuramoto-Sivashinsky equation. This works for both vector and matrix u (one or many solutions).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.Schrodinger","page":"Home","title":"ConvolutionalClosure.Schrodinger","text":"(::Schrodinger)(u, p, t)\n\nCompute right hand side of Schrodinger equation. This works for both vector and matrix u (one or many solutions).\n\n\n\n\n\n","category":"type"},{"location":"#ConvolutionalClosure.apply_filter-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.apply_filter","text":"apply_filter(W, u)\n\nApply filter to a collection of solutions.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.apply_stencils-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.apply_stencils","text":"apply_stencils(u, p)\n\nApply the periodically extended multi-diagonal matrix circdiag(-r => p[:, 1], ..., r => p[:, end]) to u for the M stencils p of size (M, 2r+1).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.apply_stencils_nonsquare-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.apply_stencils_nonsquare","text":"apply_stencils_nonsquare(u, p)\n\nFor the M stencils p of size (M, 2r+1).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.apply_stencils_transpose-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.apply_stencils_transpose","text":"apply_stencils_transpose(u, p)\n\nApply the transpose of the periodically extended multi-diagonal matrix circdiag(-r => p[:, 1], ..., r => p[:, end]) to u for the M stencils p of size (M, 2r+1).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.circulant-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.circulant","text":"circulant(n, inds, stencil)\n\nCreate circulant SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.constant_interpolator-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.constant_interpolator","text":"constant_interpolator(x, y)\n\nCreate matrix for interpolating from grid x in mathbbR^N to y in mathbbR^M. This function uses a zeroth order interpolation, i.e. the function is piece-wise constant.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.convolutional_closure-NTuple{4, Any}","page":"Home","title":"ConvolutionalClosure.convolutional_closure","text":"convolutional_closure(r, c, a, b; rng = Random.default_rng, channel_augmenter = identity)\n\nCreate closure function with\n\nArgs:\n\nr: Kernel radii (nlayer)\nc: Number of channels (nlayer + 1) (first should be equal to number of output channels in channel_augmenter)\na: Activation functions (nlayer)\nb: Bias indicators (nlayer)\n\nKwargs:\n\nrng: Random number generator\nchannelaugmenter: A function `u -> hcat(channel1(u), ..., channel_n(u))`\n\nReturn (p, closure), where p are the initial parameters and closure(u, p, t) computes the closure term.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.convolutional_matrix_closure-NTuple{4, Any}","page":"Home","title":"ConvolutionalClosure.convolutional_matrix_closure","text":"convolutional_matrix_closure(r, c, a, b; rng = Random.default_rng, channel_augmenter = identity)\n\nCreate closure function with\n\nArgs:\n\nr: Kernel radii (nlayer)\nc: Number of channels (nlayer + 1) (first should be equal to number of output channels in channel_augmenter)\na: Activation functions (nlayer)\nb: Bias indicators (nlayer)\n\nKwargs:\n\nrng: Random number generator\nchannelaugmenter: A function `u -> hcat(channel1(u), ..., channel_n(u)`\n\nReturn (p, closure), where p are the initial parameters and closure(u, p, t) computes the closure term.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.create_data-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.create_data","text":"create_data(x, K, nsample; decay = Returns(1))\n\nCreate nsample random signals on x with maximum frequency K and frequency decay decay(k).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.derivative_loss-NTuple{4, Any}","page":"Home","title":"ConvolutionalClosure.derivative_loss","text":"derivative_loss(f, p, dudt, u; nuse = size(u, 2), λ = 0)\n\nCompute derivative-fitting loss. Chooses a random subset (nuse) of the data samples at each evaluation. Note that both u and dudt are of size (sample_size..., nsample).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.eqname","page":"Home","title":"ConvolutionalClosure.eqname","text":"eqname(equation)\n\nGet name of equation.\n\n\n\n\n\n","category":"function"},{"location":"#ConvolutionalClosure.extend1D-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.extend1D","text":"extend1D(u, r)\n\nExtend the vector u periodically with an overlap of r.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.extend2D","page":"Home","title":"ConvolutionalClosure.extend2D","text":"extend2D(u, rx, ry = rx)\n\nExtend the matrix u periodically with an overlap of (rx, ry).\n\n\n\n\n\n","category":"function"},{"location":"#ConvolutionalClosure.fourier_closure-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.fourier_closure","text":"fourier_closure(n, kmax; channel_augmenter = identity, σ = gelu, [rng])\n\nFourier neural operator closure with n latent channels, wavenumber truncation at kmax, and actiavation function σ.\n\nIn addition to an intial and final point-wise lift and compression, this model is comprised of four inner Fourier layers.\n\nFor each Fourier layer, the output is σ(y + z), where\n\ny is a spatial point-wise linear transform of the input\nz is a spectral mode-wise linear transform of the truncated spectrum of the input\n\nNote: Spatial inputs can have any uniform discretization, but the number of discretization points must be at least kmax.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.gaussian-NTuple{4, Any}","page":"Home","title":"ConvolutionalClosure.gaussian","text":"gaussian(Δx, Δy, x, y)\n\nGaussian filter weight at point (x, y) for filter width (Δx, Δy).\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.gaussian-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.gaussian","text":"gaussian(Δ, x)\n\nGaussian filter weight at point x for filter width Δ.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.glorot_uniform_Float64-Tuple{Random.AbstractRNG, Vararg{Integer}}","page":"Home","title":"ConvolutionalClosure.glorot_uniform_Float64","text":"Generate random weights as in Lux.glorot_uniform, but with Float64. https://github.com/avik-pal/Lux.jl/blob/51bbf8dc489155c53f5f034b636848bdaabfc55d/src/utils.jl#L45-L48\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.linear_interpolator-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.linear_interpolator","text":"linear_interpolator(x, y)\n\nCreate matrix for interpolating from grid x in mathbbR^N to y in mathbbR^M.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.plotfield-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.plotfield","text":"plotfield(x, y, u; kwargs...)\n\nPlot solution u.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.plotmat-Tuple{Any}","page":"Home","title":"ConvolutionalClosure.plotmat","text":"plotmat(A; kwargs...)\n\nPlot matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.plotsol-Tuple{Any, Any, Any}","page":"Home","title":"ConvolutionalClosure.plotsol","text":"plotsol(x, t, u; kwargs...)\n\nPlot solution u.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.relerr-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.relerr","text":"relerr(u, v)\n\nAverage relative errors along first dimension.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.rk4-NTuple{5, Any}","page":"Home","title":"ConvolutionalClosure.rk4","text":"rk4(f, p, u₀, t, Δt)\n\nSolve ODE dudt = f(u p t) with RK4, where p are parameters.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.solve_equation-NTuple{4, Any}","page":"Home","title":"ConvolutionalClosure.solve_equation","text":"solve_equation(f, u₀, p, t; kwargs...)\n\nSolve equation from t[1] to t[end]. The ODE right hand side f should work on one vector with size (N, 1) and with multiple vectors in parallel in in a matrix of size (N, nvector). The initial conditions u₀ are of size N × n_IC. The solution is saved at t of size n_t.\n\nReturn an ODESolution acting as an array of size N × n_IC × n_t.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.top_hat-Tuple{Any, Any}","page":"Home","title":"ConvolutionalClosure.top_hat","text":"top_hat(Δ, x)\n\nTop-hat filter weight at point x for filter width Δ.\n\n\n\n\n\n","category":"method"},{"location":"#ConvolutionalClosure.trajectory_loss-NTuple{4, Any}","page":"Home","title":"ConvolutionalClosure.trajectory_loss","text":"trajectory_loss(\n    f,\n    p,\n    u,\n    t;\n    nsolution = size(u, ndims(u) - 1),\n    ntime = length(t),\n    λ = 0,\n    kwargs...,\n)\n\nCompute trajectory-fitting loss. Chooses a random subset of the solutions and time points at each evaluation. Note that u is of size (nx, nsolution, ntime)\n\n\n\n\n\n","category":"method"}]
}
